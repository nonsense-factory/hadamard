# Hadamard Error Scaling

How many errors can Hadamard encoding correct for per jth exponenet of 2?

Using the formula described in codebook.md, we can directly calculate this:
Find X = floor(2^(j-2) - 1/2)

    HM_2:
    [ 1,  1]
    [ 1, -1]

    N = 2, j = 1, 
    floor(2^(1-2) - 1/2)
    floor(sqrt(2) - 1/2)
    floor(0.914)
    X = 0

    HM_4:
    [ 1,  1,  1,  1]
    [ 1, -1,  1, -1]
    [ 1,  1, -1, -1]
    [ 1, -1, -1,  1]

    N = 4, j = 2
    floor(2^(2-2) - 1/2)
    floor(2^0 - 1/2)
    floor(0.5)
    X = 0

    HM_8: 
    [ 1,  1,  1,  1,  1,  1,  1,  1]
    [ 1, -1,  1, -1,  1, -1,  1, -1]
    [ 1,  1, -1, -1,  1,  1, -1, -1]
    [ 1, -1, -1,  1,  1, -1, -1,  1]
    [ 1,  1,  1,  1, -1, -1, -1, -1]
    [ 1, -1,  1, -1, -1,  1, -1,  1]
    [ 1,  1, -1, -1, -1, -1,  1,  1]
    [ 1, -1, -1,  1, -1,  1,  1, -1]
    
    N = 8, j = 3 
    floor(2^(3-2) - 1/2)
    floor(2 - 1/2)
    floor(1.5)
    X = 1

    HM_16:
    [ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1]
    [ 1, -1,  1, -1,  1, -1,  1, -1,  1, -1,  1, -1,  1, -1,  1, -1]
    [ 1,  1, -1, -1,  1,  1, -1, -1,  1,  1, -1, -1,  1,  1, -1, -1]
    [ 1, -1, -1,  1,  1, -1, -1,  1,  1, -1, -1,  1,  1, -1, -1,  1]
    [ 1,  1,  1,  1, -1, -1, -1, -1,  1,  1,  1,  1, -1, -1, -1, -1]
    [ 1, -1,  1, -1, -1,  1, -1,  1,  1, -1,  1, -1, -1,  1, -1,  1]
    [ 1,  1, -1, -1, -1, -1,  1,  1,  1,  1, -1, -1, -1, -1,  1,  1]
    [ 1, -1, -1,  1, -1,  1,  1, -1,  1, -1, -1,  1, -1,  1,  1, -1]
    [ 1,  1,  1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1]
    [ 1, -1,  1, -1,  1, -1,  1, -1, -1,  1, -1,  1, -1,  1, -1,  1]
    [ 1,  1, -1, -1,  1,  1, -1, -1, -1, -1,  1,  1, -1, -1,  1,  1]
    [ 1, -1, -1,  1,  1, -1, -1,  1, -1,  1,  1, -1, -1,  1,  1, -1]
    [ 1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1]
    [ 1, -1,  1, -1, -1,  1, -1,  1, -1,  1, -1,  1,  1, -1,  1, -1]
    [ 1,  1, -1, -1, -1, -1,  1,  1, -1, -1,  1,  1,  1,  1, -1, -1]
    [ 1, -1, -1,  1, -1,  1,  1, -1, -1,  1,  1, -1,  1, -1, -1,  1]

    N = 16, j = 4
    floor(2^(4-2) - 1/2)
    floor(2^2 - 1/2)
    floor(3.5)
    X = 3

    HM_32:
    [ 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1]
    [ 1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1]
    [ 1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1]
    [ 1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1]
    [ 1  1  1  1 -1 -1 -1 -1  1  1  1  1 -1 -1 -1 -1  1  1  1  1 -1 -1 -1 -1  1  1  1  1 -1 -1 -1 -1]
    [ 1 -1  1 -1 -1  1 -1  1  1 -1  1 -1 -1  1 -1  1  1 -1  1 -1 -1  1 -1  1  1 -1  1 -1 -1  1 -1  1]
    [ 1  1 -1 -1 -1 -1  1  1  1  1 -1 -1 -1 -1  1  1  1  1 -1 -1 -1 -1  1  1  1  1 -1 -1 -1 -1  1  1]
    [ 1 -1 -1  1 -1  1  1 -1  1 -1 -1  1 -1  1  1 -1  1 -1 -1  1 -1  1  1 -1  1 -1 -1  1 -1  1  1 -1]
    [ 1  1  1  1  1  1  1  1 -1 -1 -1 -1 -1 -1 -1 -1  1  1  1  1  1  1  1  1 -1 -1 -1 -1 -1 -1 -1 -1]
    [ 1 -1  1 -1  1 -1  1 -1 -1  1 -1  1 -1  1 -1  1  1 -1  1 -1  1 -1  1 -1 -1  1 -1  1 -1  1 -1  1]
    [ 1  1 -1 -1  1  1 -1 -1 -1 -1  1  1 -1 -1  1  1  1  1 -1 -1  1  1 -1 -1 -1 -1  1  1 -1 -1  1  1]
    [ 1 -1 -1  1  1 -1 -1  1 -1  1  1 -1 -1  1  1 -1  1 -1 -1  1  1 -1 -1  1 -1  1  1 -1 -1  1  1 -1]
    [ 1  1  1  1 -1 -1 -1 -1 -1 -1 -1 -1  1  1  1  1  1  1  1  1 -1 -1 -1 -1 -1 -1 -1 -1  1  1  1  1]
    [ 1 -1  1 -1 -1  1 -1  1 -1  1 -1  1  1 -1  1 -1  1 -1  1 -1 -1  1 -1  1 -1  1 -1  1  1 -1  1 -1]
    [ 1  1 -1 -1 -1 -1  1  1 -1 -1  1  1  1  1 -1 -1  1  1 -1 -1 -1 -1  1  1 -1 -1  1  1  1  1 -1 -1]
    [ 1 -1 -1  1 -1  1  1 -1 -1  1  1 -1  1 -1 -1  1  1 -1 -1  1 -1  1  1 -1 -1  1  1 -1  1 -1 -1  1]
    [ 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]
    [ 1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1]
    [ 1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1]
    [ 1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1]
    [ 1  1  1  1 -1 -1 -1 -1  1  1  1  1 -1 -1 -1 -1 -1 -1 -1 -1  1  1  1  1 -1 -1 -1 -1  1  1  1  1]
    [ 1 -1  1 -1 -1  1 -1  1  1 -1  1 -1 -1  1 -1  1 -1  1 -1  1  1 -1  1 -1 -1  1 -1  1  1 -1  1 -1]
    [ 1  1 -1 -1 -1 -1  1  1  1  1 -1 -1 -1 -1  1  1 -1 -1  1  1  1  1 -1 -1 -1 -1  1  1  1  1 -1 -1]
    [ 1 -1 -1  1 -1  1  1 -1  1 -1 -1  1 -1  1  1 -1 -1  1  1 -1  1 -1 -1  1 -1  1  1 -1  1 -1 -1  1]
    [ 1  1  1  1  1  1  1  1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1  1  1  1  1  1  1  1  1]
    [ 1 -1  1 -1  1 -1  1 -1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1  1 -1  1 -1  1 -1  1 -1]
    [ 1  1 -1 -1  1  1 -1 -1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1  1  1 -1 -1  1  1 -1 -1]
    [ 1 -1 -1  1  1 -1 -1  1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1  1 -1 -1  1  1 -1 -1  1]
    [ 1  1  1  1 -1 -1 -1 -1 -1 -1 -1 -1  1  1  1  1 -1 -1 -1 -1  1  1  1  1  1  1  1  1 -1 -1 -1 -1]
    [ 1 -1  1 -1 -1  1 -1  1 -1  1 -1  1  1 -1  1 -1 -1  1 -1  1  1 -1  1 -1  1 -1  1 -1 -1  1 -1  1]
    [ 1  1 -1 -1 -1 -1  1  1 -1 -1  1  1  1  1 -1 -1 -1 -1  1  1  1  1 -1 -1  1  1 -1 -1 -1 -1  1  1]
    [ 1 -1 -1  1 -1  1  1 -1 -1  1  1 -1  1 -1 -1  1 -1  1  1 -1  1 -1 -1  1  1 -1 -1  1 -1  1  1 -1]

    N = 32, j = 5
    floor(2^(5-2) - 1/2)
    floor(2^(3) - 1/2)
    floor(7.5)
    X = 7

    HM_64: (I'm no longer printing these, if you really want to see it, generate with HM.py)

    N = 64, j = 6
    floor(2^(6-2) - 1/2)
    floor(2^(4) - 1/2)
    floor(15.5)
    X = 15

    HM_128: 

    N = 128, j = 7
    floor(2^(7-2) - 1/2)
    floor(2^(5) - 1/2)
    floor(31.5)
    X = 31


    HM_64: (I'm no longer printing these, if you really want to see it, generate with HM.py)

    N = 256, j = 8
    floor(2^(8-2) - 1/2)
    floor(2^(6) - 1/2)
    floor(63.5)
    X = 63

## The emerging pattern should be obvious

Since Hadamard matrixes are generated as powers of two, the number of correctable errors using this
scheme is always N/4 - 1 bits of error. 

This means that there is no significant change in the rate of error correction as the input size 
grows.

# Message Efficiency

Each NxN size Hadamard matrix can be used to encode a binary message of length j + 1.
Therefore the length of the encoded message is equal to N, and grows in proportion of the message 
length L as follows:
    
    N =  8,  j = 3, L = 4
    Ratio = 4/8 = 1/2       Exactly 200% as large

    N = 16,  j = 4, L = 5
    Ratio = 5/16            Exactly 320% as large

    N = 32,  j = 5, L = 6
    Ratio = 6/32 = 3/16     Approx. 533% as large

    N = 64,  j = 6, L = 7
    Ratio = 7/64            Approx. 914% as large

    N = 128, j = 7, L = 8
    Ratio = 8/128 = 1/16    Exactly 1600% as large

The bitwise efficiency of the algorithm drops off significantly.
